import { Injectable, Logger } from '@nestjs/common';\nimport { DatabaseService } from '../../../common/database/database.service';\n\ninterface AuditLogEntry {\n  userId?: string;\n  action: string;\n  resource: string;\n  ipAddress?: string;\n  userAgent?: string;\n  success: boolean;\n  errorMessage?: string;\n  metadata?: any;\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n}\n\n@Injectable()\nexport class AuditLoggingService {\n  private readonly logger = new Logger(AuditLoggingService.name);\n\n  constructor(private prisma: DatabaseService) {}\n\n  async logSecurityEvent(entry: AuditLogEntry) {\n    try {\n      await this.prisma.auditLog.create({\n        data: {\n          userId: entry.userId,\n          action: entry.action,\n          resource: entry.resource,\n          ipAddress: entry.ipAddress,\n          userAgent: entry.userAgent,\n          success: entry.success,\n          errorMessage: entry.errorMessage,\n          metadata: entry.metadata,\n          severity: entry.severity,\n          timestamp: new Date(),\n        }\n      });\n\n      // Log critical events to application logger as well\n      if (entry.severity === 'CRITICAL') {\n        this.logger.error(`CRITICAL SECURITY EVENT: ${entry.action} on ${entry.resource}`, {\n          userId: entry.userId,\n          ipAddress: entry.ipAddress,\n          metadata: entry.metadata\n        });\n      }\n    } catch (error) {\n      this.logger.error('Failed to log audit event', error);\n    }\n  }\n\n  async logAuthenticationEvent(\n    action: 'LOGIN_SUCCESS' | 'LOGIN_FAILED' | 'LOGOUT' | 'TOKEN_REFRESH',\n    userId?: string,\n    ipAddress?: string,\n    userAgent?: string,\n    metadata?: any\n  ) {\n    const severity = action === 'LOGIN_FAILED' ? 'MEDIUM' : 'LOW';\n    \n    await this.logSecurityEvent({\n      userId,\n      action,\n      resource: 'AUTH',\n      ipAddress,\n      userAgent,\n      success: !action.includes('FAILED'),\n      metadata,\n      severity\n    });\n  }\n\n  async logDataAccess(\n    action: 'READ' | 'create' | 'update' | 'delete',\n    resource: string,\n    userId: string,\n    ipAddress?: string,\n    success = true,\n    metadata?: any\n  ) {\n    const severity = action === 'delete' ? 'HIGH' : 'LOW';\n    \n    await this.logSecurityEvent({\n      userId,\n      action: `DATA_${action.toUpperCase()}`,\n      resource,\n      ipAddress,\n      success,\n      metadata,\n      severity\n    });\n  }\n\n  async logPrivilegeEscalation(\n    userId: string,\n    fromRole: string,\n    toRole: string,\n    ipAddress?: string,\n    userAgent?: string\n  ) {\n    await this.logSecurityEvent({\n      userId,\n      action: 'PRIVILEGE_ESCALATION',\n      resource: 'USER_ROLE',\n      ipAddress,\n      userAgent,\n      success: true,\n      metadata: { fromRole, toRole },\n      severity: 'HIGH'\n    });\n  }\n\n  async logSuspiciousActivity(\n    description: string,\n    userId?: string,\n    ipAddress?: string,\n    userAgent?: string,\n    metadata?: any\n  ) {\n    await this.logSecurityEvent({\n      userId,\n      action: 'SUSPICIOUS_ACTIVITY',\n      resource: 'SYSTEM',\n      ipAddress,\n      userAgent,\n      success: false,\n      errorMessage: description,\n      metadata,\n      severity: 'CRITICAL'\n    });\n  }\n\n  async getAuditLogs(\n    userId?: string,\n    startDate?: Date,\n    endDate?: Date,\n    severity?: string,\n    limit = 100\n  ) {\n    const where: any = {};\n    \n    if (userId) where.userId = userId;\n    if (startDate || endDate) {\n      where.timestamp = {};\n      if (startDate) where.timestamp.gte = startDate;\n      if (endDate) where.timestamp.lte = endDate;\n    }\n    if (severity) where.severity = severity;\n\n    return this.prisma.auditLog.findMany({\n      where,\n      orderBy: { timestamp: 'desc' },\n      take: limit\n    });\n  }\n\n  async getSecuritySummary(userId?: string, days = 30) {\n    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\n    \n    const where: any = {\n      timestamp: { gte: startDate }\n    };\n    \n    if (userId) where.userId = userId;\n\n    const [total, failed, critical, byAction] = await Promise.all([\n      this.prisma.auditLog.count({ where }),\n      this.prisma.auditLog.count({ where: { ...where, success: false } }),\n      this.prisma.auditLog.count({ where: { ...where, severity: 'CRITICAL' } }),\n      this.prisma.auditLog.groupBy({\n        by: ['action'],\n        where,\n        _count: { action: true },\n        orderBy: { _count: { action: 'desc' } },\n        take: 10\n      })\n    ]);\n\n    return {\n      totalEvents: total,\n      failedEvents: failed,\n      criticalEvents: critical,\n      topActions: byAction.map(item => ({\n        action: item.action,\n        count: item._count.action\n      }))\n    };\n  }\n\n  async cleanupOldLogs(retentionDays = 90) {\n    const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);\n    \n    const deleted = await this.prisma.auditLog.deleteMany({\n      where: {\n        timestamp: { lt: cutoffDate },\n        severity: { not: 'CRITICAL' } // Keep critical events longer\n      }\n    });\n\n    this.logger.log(`Cleaned up ${deleted.count} old audit log entries`);\n    return deleted.count;\n  }\n}